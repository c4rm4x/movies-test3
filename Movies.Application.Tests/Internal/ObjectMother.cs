using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace Movies.Application.Tests.Internal
{
    /// <summary>
    /// Random generator class
    /// </summary>
    public static class ObjectMother
    {
        private const int DaysLimit = 365;

        internal static Random Random { get; private set; } = new Random((int)DateTime.Now.Ticks);

        /// <summary>
        /// Creates a random object based on type
        /// </summary>
        /// <typeparam name="T">Type of the object</typeparam>
        /// <param name="context">The context (if any)</param>
        /// <returns>Random object</returns>
        public static T Create<T>(Context context = null)
        {
            return (T)Create(typeof(T), context);
        }

        /// <summary>
        /// Crates a random object based on type
        /// </summary>
        /// <param name="type">Type of the object</param>
        /// <param name="context">The context (if any)</param>
        /// <returns>Random objet</returns>        
        public static object Create(Type type, Context context = null)
        {
            context = context ?? new Context();

            if (type == typeof(string)) return CreateString(Next(context.MinLength, context.MaxLength));
            else if (type == typeof(Guid)) return Guid.NewGuid();
            else if (type == typeof(DateTime)) return DateTime.Now.AddDays(Next(-DaysLimit, DaysLimit));
            else if (type == typeof(int)) return Next(context);
            else if (type == typeof(decimal)) return Convert.ToDecimal(Next(context));
            else if (type == typeof(double)) return Random.NextDouble();
            else if (type == typeof(long)) return Convert.ToInt64(Next(context));
            else if (type == typeof(short)) return Convert.ToInt16(Next(
                Math.Max(short.MinValue, context.MinValue),
                Math.Min(short.MaxValue, context.MaxValue)));
            else if (type == typeof(bool)) return Next(0, 2) == 0;
            else if (type == typeof(byte)) return Convert.ToByte(Next(
                Math.Max(byte.MinValue, context.MinValue),
                Math.Min(byte.MaxValue, context.MaxValue)));
            else if (type.IsClass) return CreateComplexObject(type, context);
            else return Default(type);
        }

        private static int Next(Context context)
        {
            return Next(context.MinValue, context.MaxValue);
        }

        private static int Next(int minValue = 1, int maxValue = int.MaxValue)
        {
            return Random.Next(minValue, maxValue);
        }

        private static string CreateString(int length)
        {
            var builder = new StringBuilder();

            for (int i = 0; i < length; i++)
                builder.Append(Convert.ToChar(Convert.ToInt32(Math.Floor(26 * Random.NextDouble() + 65))));

            return builder.ToString();
        }

        private static object CreateComplexObject(Type type, Context context)
        {
            try
            {
                var instance = Activator.CreateInstance(type, true);

                foreach (var propertyInfo in GetSetters(type))
                    propertyInfo.SetValue(instance, Create(propertyInfo.PropertyType, context));

                return instance;
            }
            catch (Exception)
            {
                return null; // In case a new instance of given type cannot be created
            }
        }

        private static IEnumerable<PropertyInfo> GetSetters(Type type)
        {
            return type
                .GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.SetProperty)
                .Where(p => p.GetSetMethod(true) != null && !p.GetMethod.IsVirtual);
        }

        private static object Default(Type type)
        {
            return type.IsValueType
                ? Activator.CreateInstance(type)
                : typeof(IEnumerable).IsAssignableFrom(type)
                ? CreateEnumerableInstance(type) : null;
        }

        private static object CreateEnumerableInstance(Type type)
        {
            var genericType = type.GetGenericArguments().FirstOrDefault();

            return genericType != null
                ? Activator.CreateInstance(typeof(List<>).MakeGenericType(genericType))
                : null;
        }
    }

    /// <summary>
    /// Object mother contex
    /// </summary>
    public class Context
    {
        private const int MaxStringLength = 100;

        /// <summary>
        /// Gets the min length of the autogenerated strings
        /// </summary>
        public int MinLength { get; private set; } = 1;

        /// <summary>
        /// Gets the max length of the autogenerated strings
        /// </summary>
        public int MaxLength { get; private set; } = MaxStringLength;

        /// <summary>
        /// Gets the min value to use when random generation (if any)
        /// </summary>
        public int MinValue { get; private set; } = 1;

        /// <summary>
        /// Gets the max value to use when random generation (if any)
        /// </summary>
        public int MaxValue { get; private set; } = int.MaxValue;

        internal Context()
        {

        }

        /// <summary>
        /// Creates a new object mother context using minLenght to restrict autogenerated string
        /// </summary>
        /// <param name="minLength">The min length</param>
        /// <returns>A new instance of Context with the given minLength restriction</returns>
        public static Context WithMinLength(int minLength)
        {
            return new Context
            {
                MinLength = minLength
            };
        }

        /// <summary>
        /// Creates a new object mother context using maxLenght to restrict autogenerated string
        /// </summary>
        /// <param name="maxLength">The max length</param>
        /// <returns>A new instance of Context with the given maxLength restriction</returns>
        public static Context WithMaxLength(int maxLength)
        {
            return new Context
            {
                MaxLength = maxLength
            };
        }

        /// <summary>
        /// Creates a new object mother context using length to restrict autogenerated strings
        /// </summary>
        /// <param name="length">The exact length</param>
        /// <returns>A new instance of Context with the given exact length restriction</returns>
        public static Context WithExactLength(int length)
        {
            return new Context
            {
                MinLength = length,
                MaxLength = length,
            };
        }

        /// <summary>
        /// Creates a new object mother context with the given min value
        /// </summary>
        /// <param name="minValue">The min value</param>
        /// <returns>A new instance of Context with the given minValue restriction</returns>
        public static Context WithMinValue(int minValue)
        {
            return new Context
            {
                MinValue = minValue
            };
        }

        /// <summary>
        /// Creates a new object mother context with the given max value
        /// </summary>
        /// <param name="maxValue">The max value</param>
        /// <returns>A new instance of Context with the given maxValue restriction</returns>
        public static Context WithMaxValue(int maxValue)
        {
            return new Context
            {
                MaxValue = maxValue
            };
        }

        /// <summary>
        /// Creates a new object mother context with the given range
        /// </summary>
        /// <param name="minValue">The min value</param>
        /// /// <param name="maxValue">The max value</param>
        /// <returns>A new instance of Context with the given range restriction</returns>
        public static Context WithRange(int minValue, int maxValue)
        {
            return new Context
            {
                MinValue = minValue,
                MaxValue = maxValue
            };
        }
    }
}
